REM Refer to the C manual for details on these functions. The C function names
REM are given in the line under the PROC definition below.

REM ==========================================================================
REM NB!!!
REM The sprite, bitmap and file ids are WSRV IDs not OPL's so 
REM don't pass them to any OPL function.
REM When you have finished using these bitmaps or sprites, use wFree: to free
REM each of them passing the WSRV id%.
REM You can close the bitmaps to save memory once you have called wCrtSpr%:.
REM WSRV doesn't need the bitmaps to be open to use them in a sprite.
REM You must clearly open a bitmap again or leave it open if you need to use
REM its handle any more.
REM ==========================================================================

REM You can use gInitB%: to open a bitmap file containing more than one bitmap
REM once and for all and gGetB%: to read them. Note that the C SDK manual has
REM a bug saying that gGetBit() returns zero on no error when in fact it
REM returns the WSRV bitmap ID.
REM gOpenB%: will open the file, load the bitmap and close the file again.

REM pPoint% args must point to two integers giving pixels {x,y}.
REM pSprite% points to a W_SPRITE structure listing the 6 bitmaps IDs in the 
REM bitmap-set in the same order as in OPL's appendSprite(), followed by two
REM integers giving the pixel offset {x,y} followed by the time between 
REM bitmap-sets. Use gInitB%: with gGetB%: (or use gOpenB%:) to load the
REM bitmaps, getting these IDs.
REM The window ID required for wCrtSpr%: is a WSRV ID not OPL's. Use the
REM OPL gInfo i%() command to find this id in i%(31).

rem -------------------------------------------------------------------------

#ifndef _OPLLINT

proc gInitB%:(file$,pCount%)
  rem gInitBit()
  local f$(130)

  f$=file$
  return call($e78d,uadd(addr(f$),1),0,0,pCount%)
endp

rem -------------------------------------------------------------------------

proc gGetB%:(hand%,index%,flags%,pPoint%)
  rem gGetBit()
  rem !!! returns the WSRV bitmap ID !!!
  rem flags% should be zero for readOnly or 1 for readWrite

  return call($e88d,hand%,index%,flags%,pPoint%)
endp

rem -------------------------------------------------------------------------

proc gOpenB%:(file$,index%,flags%,pPoint%)
  rem gOpenBit()
  rem flags% should be zero for readOnly or 1 for readWrite
  local f$(130)

  f$=file$
  return call($ae8d,uadd(addr(f$),1),index%,flags%,pPoint%)
endp

rem -------------------------------------------------------------------------

proc wCrtSpr%:(wId%,pPoint%,flags%,count%,pSprite%)
  rem wCreateSprite()
    
  return call($f68d,wId%,pPoint%,flags%,pSprite%,count%)
endp

rem -------------------------------------------------------------------------

proc wSetSpr%:(id%,pPoint%,index%,pSprite%)
  rem wSetSprite()

  return call($f58d,id%,pPoint%,index%,0,pSprite%)
endp

rem -------------------------------------------------------------------------

proc gIniMlt%:(file$,count%)
  rem gInitMultiSave()
  local ax%,bx%,cx%,dx%,si%,di%
  local f$(130)
#ifdef _OPLLINT
  dx%=si%=di%
#endif
  f$=file$
  cx%=count%
  bx%=uadd(addr(f$),1)
  ax%=$ff00
  os($8d,addr(ax%))
  return ax%
endp

rem -------------------------------------------------------------------------

proc gSavMlt%:(handle%,bitmap%)
  rem gSaveMultiBit()
  local ax%,bx%,cx%,dx%,si%,di%
#ifdef _OPLLINT
  dx%=si%=di%
#endif
  cx%=bitmap%
  bx%=handle%
  ax%=$ff01
  os($8d,addr(ax%))
  return ax%
endp

rem -------------------------------------------------------------------------

proc gEndMlt%:(handle%)
  rem gEndMultiSave()
  local ax%,bx%,cx%,dx%,si%,di%
#ifdef _OPLLINT
  dx%=si%=di%=cx%
#endif
  bx%=handle%
  ax%=$ff03
  os($8d,addr(ax%))
  return ax%
endp

rem -------------------------------------------------------------------------

proc wFree:(id%)
  rem wFree()
  rem Frees any WSRV entity - not for use with OPL IDs

  call($118d,id%)
endp
#endif
/*
Dont let OPLLINT process this file as it's a library the LEX file will
surpress the warnings
*/
